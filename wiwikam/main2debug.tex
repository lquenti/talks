\documentclass{beamer}
\title{What Every Programmer Should Know About Memory}
\author{Lars Quentin}
\date{09.02.2022}
\usetheme[numbering=none]{metropolis}
\usepackage{xcolor}
\begin{document}


% - Die Grafik ist veraltet, das wichtigste sind
%   - USB/USB-C/Thunderbolt
%   - Festplatten: HDDs (Hard Disk Drives) und SSDs (Solid State Drives) via SATA (Serial ATA)
%   - Ethernet und WiFi-Karten
%   - Und anderer alter Kram wie hier IDE (Integrated Drive Electronics) /PATA (Parallel ATA)
%
% - Der Memory alleine waere doch zu langsam und die Register zu klein.
%   Lasst uns nochmal etwas genauer den CPU angucken.
\begin{frame}[t]
\frametitle{Wie ist ein PC aufgebaut?}
\centering
\includegraphics[width=7cm]{architecture7.png}
\end{frame}



% - Ein Core hat einen Level 1 Cache.
% - (Ein Cache ist ein Zwischenspeicher, wo man Sachen speichert die man gerade genutzt hat,
%   falls man sie in der nahen Zukunft wieder braucht)
% - Dieser ist SEHR schnell
% - Bei mir hier 128KB gross. Unbezahlbar teuer, deswegen nur so klein.
% - Dieser wird fuer Sachen genutzt mit denen der Prozessor zuletzt gearbeitet hat
%   - Falls man auf die Variablen wieder schnell zugreifen muss
%   - Wie zum Beispiel ein i bei einer for loop
%   - oder ein kleines Objekt was man dauerhaft veraendet
%
% - Mehrere Threads auf einen Core teilen sich den selben L1 Cache
%
% - Wobei, das war nur die halbe Wahrheit
\begin{frame}[t]
\frametitle{Wie ist ein CPU aufgebaut?}
\centering
\includegraphics[height=5cm]{CPU2.PNG}
\end{frame}

% - Eigentlich gibt es 2 Level 1 Caches.
% - Einen fuer Instruktionen (L1i) (das Programm selbst) und einen fuer Daten (L1d) (Variablen und so)
% - Sprich bei mir jeweils 64 KB
% - Diese Unterteilung kommt dadurch, dass
%   - Sie andere raeumliche Eigenschaften haben.
%     Instruktionen sind meist hintereinander,
%     Daten, gerade im Heap, oft verteilt.
%   - Man brauch andere Metainformationen.
%     Instruktionen sind zB read-only
%     Auch wenn Haskeller diesen Fakt hassen, Daten darf man veraendern.
%
% - Jedoch
\begin{frame}[t]
\frametitle{Wie ist ein CPU aufgebaut?}
\centering
\includegraphics[height=5cm]{cpu3.png}
\end{frame}

% - Es gibt einen L3 cache.
% - Der ist noch langsamer, und noch groesser.
% - Bei mir 8MB, sprich 8x L2, und 128x mein L1 cache.
% <PAUSE>
\begin{frame}[t]
\frametitle{Wie ist ein CPU aufgebaut?}
\centering
\centerline{\includegraphics[width=12cm]{cpu6.png}}
\end{frame}

\begin{frame}
\centering
\Huge
    Was passiert, wenn man auf eine Variable zugreift?
\end{frame}



% Dann geht alles wieder zurueck an den CPU Core, und die Daten werden in den Caches gespeichert
%
% Am Ende: 
\begin{frame}{Was passiert, wenn man auf eine Variable zugreift?}
\vspace*{0.5cm}
\centerline{\includegraphics[height=8cm]{trace6.png}}
\end{frame}

\begin{frame}
\centering
\Huge
    Wie schnell sind die Caches?
\end{frame}


% Um ehrlich zu ein, ich war zu faul das selbst zu benchen, weil man die Caches nicht direkt
% ansprechen muss und dann so... Magie machen muss um sie zu isolieren
% <PAUSE>
% ...
% <LAST PAUSE>
% Zahlen sind doof. Lasst uns das visualisieren.
\begin{frame}
\frametitle{Wie schnell sind die Caches}
\begin{itemize}
    \item Level 1 CPU Cache: 1ns
    \\~\\
    \item Level 2 CPU Cache: 4.7ns
    \\~\\
    \item RAM: 83ns
    \\~\\
    \item HDD: 13.7ms
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Wie schnell sind die Caches (visualisiert)}
\centerline{\includegraphics[width=12cm]{sizes3.png}}
\end{frame}

\begin{frame}
\frametitle{Wie schnell sind die Caches (visualisiert)}
\centerline{\includegraphics[width=12cm]{sizes4.png}}
\end{frame}

% Am Ende:
% - So wo wir gesehen haben wie nuetzlich es ist alles zu cachen
% - Wie funktionieren die CPU caches?
% Vorher noch ein Disclaimer
{
\usebackgroundtemplate{\includegraphics[width=\paperwidth, height=280px]{100_whales.png}}%
\begin{frame}
\end{frame}
}


% Am Ende: So, jetzt koennen wir uns angucken wie ein CPU Cache 
\begin{frame}
\frametitle{Wir reden im folgenden von CPU Caches}
{
\centering
CPU Caches cachen den RAM, NICHT die Festplatte\\~\\
}

Fuer Infos zu Festplattencaching: \texttt{https://linuxatemyram.com}\\~\\
\centerline{\includegraphics[height=5cm]{linuxatemyram.png}}
\end{frame}

% Am Ende:
% - Aber genau genommen sieht es eher so aus:
\begin{frame}
\frametitle{Wie ist ein CPU Cache aufgebaut? (Hier L1)}
\begin{itemize}
    \item Jeder Cache hat eine Groesse\\~\\
\end{itemize}
\centerline{\includegraphics[width=12cm]{cell1.png}}
\end{frame}

% - Der L1 Cache wird in lines von 64 byte aufgeteilt
% - Warum macht man das? Es ist ein Tradeoff.
%   - Mehr waere effizienter (da jeder Cache-Eintrag auch Metadaten hat, somit prozentual weniger)
%   - Jeoch auch mehr verschwendet (weil man immer ganze Cache lines holen muss)
%   - Mehr misses weil man weniger cache lines hat
\begin{frame}
\frametitle{Wie ist ein CPU Cache aufgebaut? (Hier L1)}
\begin{itemize}
    \item Der Cache wird in Cache Lines aufgeteilt\\(eigentlich 2048, hier 8)\\
\end{itemize}
\centerline{\includegraphics[width=12cm]{cell2.png}}
\end{frame}

\begin{frame}

{
\centering
\huge
Wie f\"ugen wir in den Cache ein?
}
\end{frame}

% - Erklaeren was Fully Associative Cache ist
%   - Wir speichern einfach an beliebige Stelle
% - Die roten sind alle belegt, die Gruenen sind alle frei.
% - Wir haben die folgende Addresse
%   - Das 0x heisst uebrigens nur, dass es im hexadezimalen Zahlensystem ist.
%
% - Wenn alle voll sind, dann schmeissen wir den aeltesten raus (Least recently used, LRU)
%
% - Somit nehmen wir einfach einen beliebigen freien
\begin{frame}
\frametitle{M\"oglichkeit 1: Fully Associative Cache}
\centerline{\includegraphics[width=12cm]{fac1.png}}
Adresse: 0x7ffc4322c7f4
\end{frame}


% Nun die Frage: Angenommen es kommt eine Addresse, wie finden wir heraus ob wir es im Cache haben?
\begin{frame}
\frametitle{M\"oglichkeit 1: Fully Associative Cache}
\centerline{\includegraphics[width=12cm]{fac2.png}}
Adresse: 0x7ffc4322c7f4
\end{frame}

% Bei zu langsam:
%   - Bedenkt dass wir diesen drecksteuern L1 cache nur nutzen weil er so schnell ist.
%   - Wenn jeder Zugriff 4 Zyklen braucht, dann braucht das bei L1 32 Zyklen
%   - Das ist allein bei L1 Faktor 8 langsamer!
%
% Bei zu teuer:
%   - Mein L1i cache hat alleine 1024 lines 
\begin{frame}
\frametitle{Ist mein aktueller Wert im Cache?}
\begin{block}{M\"oglichkeit 1: Wir gehen \"uber alle Werte und gucken nach}
\begin{itemize}

\item Theoretisch moeglich

\item aber VIEL zu langsam!
\end{itemize}
\end{block}

\begin{block}{M\"oglichkeit 1: Wir gucken alle gleichzeitig nach}
\begin{itemize}

\item Auch theoretisch moeglich

\item aber VIEL zu teuer!
\end{itemize}

\end{block}
\begin{block}{Fazit: F\"ur aktuelle Cache-Gr\"o\ss{}en unbrauchbar!}
\end{block}
\end{frame}

% Fuer direct mapped cache entscheiden wir anhand der Addresse einen Platz.
% Lasst uns die Addresse kurz in Binaer umwandeln.
\begin{frame}
\frametitle{M\"oglichkeit 2: Direct Mapped Cache}
\centerline{\includegraphics[width=12cm]{fac1.png}}
Adresse: 0x7ffc4322c7f4
\end{frame}

% Okay, wie entscheiden wir nun aus der Addresse welche der 8 Cache Lines wir nehmen?
%
% - Wir erinnern uns dass eine line 64 byte sind. Also beschreiben die letzten 6 bit in der
%   Adresse nur, welchen Teil wir haben wollen.
%   - Weil man mit 6 bit 2^6 Zahlen darstellen kann.
%   - Trennen wir den Teil mal ab.
\begin{frame}
\frametitle{M\"oglichkeit 2: Direct Mapped Cache}
\centerline{\includegraphics[width=12cm]{fac1.png}}
011111111111110001000011001000101100011111110100
\end{frame}

% Fuer 8 Speicherstellen brauchen wir 3 bits (0-1, 2-3, 4-7)
% 
% Nun ist die Frage: Nehmen wir die von Links oder rechts?
%
% Meistens liesst man Daten hintereinander. Somit haben die die selben oberen Stellen.
% Damit es sich auf verschiedene cache lines verteilt, lass uns die unteren nehmen!
\begin{frame}
\frametitle{M\"oglichkeit 2: Direct Mapped Cache}
\centerline{\includegraphics[width=12cm]{fac1.png}}
011111111111110001000011001000101100011111 {\color{orange}110100}
\end{frame}

% Den restlichen Teil nehmen wir dann einfach, um zu gucken ob da auch unsere Addresse drin ist.
% Weil es koennen ja Kollisionen passieren, blablabla
% Den Teil speichern wir mit in die Zelle.
\begin{frame}
\frametitle{M\"oglichkeit 2: Direct Mapped Cache}
\centerline{\includegraphics[width=12cm]{fac1.png}}
011111111111110001000011001000101100011 {\color{blue}111} {\color{orange}110100}
\end{frame}

% Nun lass es uns mal in Binaer umwandeln
\begin{frame}
\frametitle{M\"oglichkeit 2: Direct Mapped Cache}
\centerline{\includegraphics[width=12cm]{fac1.png}}
{\color{brown}011111111111110001000011001000101100011} {\color{blue}111} {\color{orange}110100}
\end{frame}

% Somit speichern den Inhalt der Addresse in
% - Zelle 8 (binaerzahlen sind 0 indexiert)
% - mit Pruefzahl 274.846.552.419 ab
% und wir wollen eigentlich nur
% - ab Offset 52!
\begin{frame}
\frametitle{M\"oglichkeit 2: Direct Mapped Cache}
\centerline{\includegraphics[width=12cm]{dmc1.png}}
{\color{brown}274.846.552.419} {\color{blue}7} {\color{orange}52}\\

Leider gibt es eine Problematik...
\end{frame}

% Nach dem ersten:
%   - Nun gehen wir im Speicher weiter und ueberschreiten die Cache Line Grenze
% Vor der Kollision:
%   - Nun lesen wir eine globale Variable ein.
%
% Am Ende:
%   - Die Loesung: Wir vermischen beides!
\begin{frame}
\frametitle{Eine Problematik}
Lasst uns ein paar Adressen durchgehen.

\begin{itemize}
    \item {\color{brown}274.846.552.419} {\color{blue}7} {\color{orange}52}
    
    \item {\color{brown}274.846.552.419} {\color{blue}8} {\color{orange}0}
    
    \item {\color{brown}319.257.156.827} {\color{blue}7} {\color{orange}32}
    
\end{itemize}
Mit 3 Variablen hatten wir bereits eine Kollision!\\
Kein effizient genutzter Speicher.
\end{frame}


% Die einzelnen Mengen werden wie ein Direct Mapped Cache angesprochen
%   - Somit koennen wir in 4 Zyklen (durch unser Pseudohashing) nachgucken wohin es muss
% Jede Menge ist intern Associatively Cached. Sprich der Platz ist beliebig.
%   - Somit muessen wir nur $n$ nachgucken, bei mir im PC ist n=8.
%   - Das ist noch gut bezahlbar, 8 gleichzeitig nachzugucken.
%
% Das ist so ein bisschen wie offenes Hashing, wo man am Ende der Buckets ne LinkedList hat.
%
% Also wandeln wir es wieder in binaer um:
\begin{frame}
\frametitle{M\"oglichkeit 3: $n$-way Associative Cache (hier $n=2$)}
\centerline{\includegraphics[width=12cm]{nac1.png}}
Adresse: 0x7ffc4322c7f4
\end{frame}

% Die Cache line sizes sind immer noch 64 byte.
% Also koennen wir die Offset wieder ignorieren.
\begin{frame}
\frametitle{M\"oglichkeit 3: $n$-way Associative Cache (hier $n=2$)}
\centerline{\includegraphics[width=12cm]{nac1.png}}
011111111111110001000011001000101100011111110100
\end{frame}

% Wir haben 4 ansprechbare Mengen, somit brauchen wir 2 bits fuers Caching
\begin{frame}
\frametitle{M\"oglichkeit 3: $n$-way Associative Cache (hier $n=2$)}
\centerline{\includegraphics[width=12cm]{nac1.png}}
011111111111110001000011001000101100011111 {\color{orange}110100}
\end{frame}

% Und der Rest ist wieder nur unser Check, um zu gucken ob das wirklich die gewollte Adresse ist
\begin{frame}
\frametitle{M\"oglichkeit 3: $n$-way Associative Cache (hier $n=2$)}
\centerline{\includegraphics[width=12cm]{nac1.png}}
0111111111111100010000110010001011000111 {\color{blue}11} {\color{orange}110100}
\end{frame}

% Wandeln wir es nun wieder in Binaer um
\begin{frame}
\frametitle{M\"oglichkeit 3: $n$-way Associative Cache (hier $n=2$)}
\centerline{\includegraphics[width=12cm]{nac1.png}}
{\color{brown}0111111111111100010000110010001011000111} {\color{blue}11} {\color{orange}110100}
\end{frame}

% Und nun koennen wir es an Stelle 4 (0 based indexing) speichern.
\begin{frame}
\frametitle{M\"oglichkeit 3: $n$-way Associative Cache (hier $n=2$)}
\centerline{\includegraphics[width=12cm]{nac1.png}}
{\color{brown}549.693.104.839} {\color{blue}3} {\color{orange}52}
\end{frame}

% Okay, cool! Das wird dann auch in der Realitaet genutzt.
% Lasst uns nochmal kurz wiederholen:
\begin{frame}
\frametitle{M\"oglichkeit 3: $n$-way Associative Cache (hier $n=2$)}
\centerline{\includegraphics[width=12cm]{nac2.png}}
{\color{brown}549.693.104.839} {\color{blue}3} {\color{orange}52}
\end{frame}

% Am Ende:
%   - Damit sich der Kreis schliesst
\begin{frame}
\frametitle{\"Uberblick Cache Associativity}
Es gibt
\begin{itemize}
    
    \item \textbf{Fully Associative} wo frei zuordbar und alles gecheckt werden muss
    
    \item \textbf{Direct Mapped}, wo mit Hashing eindeutig zugeordnet wird
    
    \item \textbf{$n$-way Associative Cache} Es gibt Mengen der L\"ange $n$
    
    \begin{itemize}
        \item Zwischen den Mengen wird Directly Mapped (gehasht)
        
        \item Innerhalb der Mengen ist es Fully Associative
    \end{itemize}
\end{itemize}
\end{frame}



% Die Theorie ist ja cool und so, aber...
%
% Erwaehnen, dass es der letzte Punkt ist.
%
% Lasst uns noch schnell ueber 3 simple Moeglichkeiten gehen.
\begin{frame}
\centering
{
\Huge Sooooooooooo\\~\\
}

Wie kann man den Cache optimieren?
\end{frame}

% Structs aufbrechen:
%   - Wenn ihr manches oft braucht, manches selten, dann 
%   - Weniger structs brauchen weniger Speicher
%     - Weniger Speicher braucht weniger Cache Lines
%     - Weniger Cache Lines heisst mehr Platz zum Cachen
%     - Und es heisst auch, dass man weniger Kollisionen hat
%
% 


% So, der Code sieht okay aus oder?
%
% pahole (kurz: PokeAHole) ist ein Tool, das automatisch nach structs analysiert und nach Loechern sucht.
% Was genau Loecher sind und warum sie auftreten zeige ich gleich.
\begin{frame}{Optimierung 1: \texttt{struct}s umstrukturieren!}
Gucken wir uns mal folgenden Code an:
\centerline{\includegraphics[height=6cm]{example1.png}}

Lassen wir \texttt{pahole} mal dr\"uberschauen!
\end{frame}



% In zeile 12 sehen wir, dass die erste cache line voll ist.
% Jedoch nutzen wir in der 2. line fuer unser Struct nur 16 von 64 byte.
%
% Angenommen, uns interessiert meistens nur wie viel eingenommen wurde.
% Dann reicht es ja, nur paid, euro und cent zu haben.
%
% Wenn man dann das struct aufbricht, kriegt man doppelt so viele Bestellungen in den L1 Cache!
\begin{frame}{Optimierung 1: \texttt{pahole} zur Rettung!}
\centerline{\includegraphics[height=6cm]{example5.png}}
\end{frame}

% Warum will man Daten nicht in den Cache speichern?
%  - Wenn man weiss, dass man sie eh laenger nicht anfaesst.
%  - Oder wenn man so viele Daten schreibt dass es danach eh wieder weg ist.
%  - Dann schreibt man einfach direkt in den Memory.
% <PAUSE>
% Ich geh nicht weiter darauf ein weil das eww Code ist, aber wenn ihr es braucht wisst ihr dass es
% existiert.
\begin{frame}{Optimerung 2: Non-temporale write operationen.}
Man kann Daten auch direkt in das Memory schreiben.\\

Der Code wird dann aber eww.\\~\\
\centerline{\includegraphics[height=5cm]{nontemporal.png}}
\end{frame}

% Die Leute die Info 2 gehoert haben wissen das bereits.
% Die operands koennen erst gefetched werden wenn man weiss wie viele Operanden die aktuelle
% instruktion braucht!
\begin{frame}{Optimierung 3: Pipelining verbessern}
Eine Instruktion besteht im Prozessor aus 5 Schritten:\\
\begin{enumerate}
    \item Instruction fetch
    
    \item instruction decode
    
    \item operands fetch
    
    \item execute operation
    
    \item operands store
\end{enumerate}
\end{frame}

\begin{frame}{Optimierung 3: Pipelining verbessern}
\centerline{\includegraphics[width=12cm]{if1.png}}
\end{frame}

% Das ist moeglich weil im Prozessor verschiedene Schaltnetze fuer die verschiedenen Sachen
% zustaendig sind
%
% -> Das nennt sich Pipelining
%
% Nun kann dieser nur gut pipelinen wenn er auch wirklich weiss was die naechsten Instruktionen sind.
% Was ist nun, wenn wir an ein if-else kommen? Woher soll der Prozessor wissen ob er den if oder den
% else vorbereiten soll?
%
\begin{frame}{Optimierung 3: Pipelining verbessern}
\centerline{\includegraphics[width=12cm]{if2.png}}
\end{frame}

% Fragt mich bitte nicht in welchen ekeligen Randbedingungen man die Doppelverneinung braucht.
% In JS wird das als implizites bool casting genommen
\begin{frame}{Optimierung 3: Pipelining verbessern}
\centerline{\includegraphics[width=12cm]{likely1.png}}
~\\~\\~~
\centerline{\includegraphics[width=5.5cm]{likely2.png}}
\end{frame}

\begin{frame}{Falls ihr mehr lernen wollt...}
\begin{columns}
    \begin{column}{0.48\textwidth}
        \centerline{\includegraphics[height=7cm]{paper.png}}
    \end{column}
    
    \begin{column}{0.48\textwidth}
        Was wir ausgelassen haben:
        \begin{itemize}
            \item Elektrotechnik
            \item Non-Uniform Memory Access
            \item Cachesynchronisation zwischen Prozessorkernen
            \item Virtual Memory, Memory Management Unit, Translate Lookaside Buffer
            \item Write cache flushing
        \end{itemize}
    \end{column}
\end{columns}
\end{frame}

\begin{frame}
\centering
{\Huge
Vielen Dank f\"ur die Aufmerksamkeit!
}\\
Fragen?
\end{frame}

\end{document}